# Сервис-ориентированная архитектура

## Лабораторная работа №3

Вариант №9192

### Задание:

Переработать веб-сервисы из лабораторной работы #2 таким образом, чтобы они реализовывали основные концепции микросервисной архитектуры. Для этого внести в оба сервиса -- "вызываемый" и "вызывающий" перечисленные ниже изменения.

**Изменения в "вызываемом" сервисе:**

- Сконфигурировать окружение для работы сервиса на платформе Spring Boot.
- Запустить второй экземпляр сервиса на другом порту. Реализовать балансировку нагрузки между экземплярами с помощью Haproxy.
- Реализовать механизм Service Discovery. Для этого установить Consul и интегрировать свой сервис с ним, автоматически регистрируя в момент запуска.

**Изменения в "вызывающем" сервисе:**

- Разделить приложение на два модуля -- веб-приложение с веб-сервисом и EJB-jar с бизнес-компонентами.
- Переместить всю логику из класса сервиса в Stateless EJB. В классе сервиса оставить только обращение к методам бизнес-интерфейса. EJB-компонент должен быть доступен удалённо (иметь Remote-интерфейс).
- Сформировать на уровне сервера приложений пул компонентов EJB настраиваемой мощности, динамически расширяемый при увеличении нагрузки.
- Настроить второй экземпляр сервера приложений на другом порту, "поднять" на нём вторую копию веб-сервиса и пула EJB.
- Настроить балансировку нагрузки на оба запущенных узла через Haproxy.

**Оба веб-сервиса и клиентское приложение должны сохранить полную совместимость с API, реализованными в рамках предыдущих лабораторных работ.**

---

## Архитектура решения

### Компоненты:

```
┌─────────────┐     ┌──────────────────────────────────────────┐
│   Frontend  │────>│              HAProxy                     │
│   (Nginx)   │     │  :8443 -> City Service (Round Robin)     │
└─────────────┘     │  :8444 -> Genocide Service (Round Robin) │
                    └──────────────────────────────────────────┘
                              │                    │
              ┌───────────────┼───────────────┐    │
              ▼               ▼               │    │
    ┌──────────────┐  ┌──────────────┐       │    │
    │City Service 1│  │City Service 2│       │    │
    │ (Spring Boot │  │ (Spring Boot │       │    │
    │  + WildFly)  │  │  + WildFly)  │       │    │
    └──────┬───────┘  └──────┬───────┘       │    │
           │                 │               │    │
           ▼                 ▼               │    │
    ┌─────────────────────────────────┐      │    │
    │           Consul                │      │    │
    │    (Service Discovery)          │      │    │
    └─────────────────────────────────┘      │    │
                                             │    │
              ┌──────────────────────────────┼────┘
              ▼                              ▼
    ┌───────────────────┐      ┌───────────────────┐
    │Genocide Service 1 │      │Genocide Service 2 │
    │  (WildFly + EJB)  │      │  (WildFly + EJB)  │
    │                   │      │                   │
    │  ┌─────────────┐  │      │  ┌─────────────┐  │
    │  │  EJB Pool   │  │      │  │  EJB Pool   │  │
    │  │(genocide-   │  │      │  │(genocide-   │  │
    │  │   pool)     │  │      │  │   pool)     │  │
    │  └─────────────┘  │      │  └─────────────┘  │
    └───────────────────┘      └───────────────────┘
```

### City Service (Вызываемый):
- **Платформа:** Spring Boot 3.5 на WildFly
- **Service Discovery:** Spring Cloud Consul
- **Балансировка:** HAProxy (Round Robin)
- **Экземпляры:** 2 (city-service-1, city-service-2)

### Genocide Service (Вызывающий):
- **Платформа:** Jakarta EE 10 на WildFly
- **Архитектура:** EAR (EJB + WAR)
  - `ejb/` - Stateless EJB с Remote интерфейсом
  - `web/` - JAX-RS веб-сервис
  - `ear/` - Enterprise Application Archive
- **EJB Pool:** genocide-pool (настраиваемый размер через `EJB_POOL_MAX_SIZE`)
- **Балансировка:** HAProxy (Round Robin)
- **Экземпляры:** 2 (genocide-service-1, genocide-service-2)

---

## Быстрый старт

### 1. Сгенерировать SSL сертификаты:
```bash
cd ssl
./generate-certs.sh
```

### 2. Собрать проекты:
```bash
# City Service
cd city-service
./gradlew clean build -x test

# Genocide Service
cd genocide-service
./gradlew clean build -x test
```

### 3. Запустить все сервисы:
```bash
docker compose up -d --build
```

### 4. Проверить статус:
- **HAProxy Stats:** http://localhost:8404/stats
- **Consul UI:** http://localhost:8500
- **Frontend:** https://localhost
- **Swagger UI:** http://localhost:8083

---

## Конфигурация EJB пула

Размер пула EJB настраивается через переменную окружения:
```yaml
environment:
  - EJB_POOL_MAX_SIZE=20  # Максимальный размер пула
```

Пул автоматически расширяется при увеличении нагрузки до заданного максимума.

---

## API Endpoints

### City Service (через HAProxy :8443):
- `POST /cities/filter` - Фильтрация городов
- `POST /cities` - Создать город
- `GET /cities/{id}` - Получить город
- `PUT /cities/{id}` - Обновить город
- `DELETE /cities/{id}` - Удалить город

### Genocide Service (через HAProxy :8444):
- `POST /genocide/kill/{id}` - Уничтожить население города
- `POST /genocide/move-to-poorest/{id}` - Переселить в беднейший город

---

**Вопросы к защите лабораторной работы:**

1. Микросервисная архитектура. Особенности реализации. Сходства и отличия от "обычной" СОА.
2. Разработка сервисов в микросервисной архитектуре. Стандарты и технологии. Принципы декомпозиции приложений на микросервисы.
3. Масштабируемость микросервисных приложений. Балансировщики нагрузки.
4. Концепция Service Discovery. Подходы и технологические решения.
5. Consul. Установка и конфигурация. Регистрация сервисов.
6. Разработка микросервисов на Java EE. Реализация Service Discovery и балансировки нагрузки.
7. Разработка микросервисов на Spring. Интеграция с балансировщиками нагрузки и провайдерами Serviсе Discovery.
8. Spring Cloud. Особенности, отличия от "голого" Spring Boot. Spring Cloud Netflix.